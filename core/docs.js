// FILE: /SYSTEM/CORE/docs.js
// VERSION: 2.0.0
// BUILD DATE: 2025-09-22
//
// DOCS.JS - CORE DOCUMENTATION SERVICE
//
// PURPOSE:
//   Core system service that collects, manages, and provides access to application
//   documentation. Acts as a centralized registry for all app documentation with
//   search, filtering, and metadata management capabilities.
//
// RESPONSIBILITIES:
//   • Automatically collect documentation from registered applications
//   • Provide unified API for documentation access across the system
//   • Support multiple documentation sources (embedded, external, auto-generated)
//   • Maintain documentation metadata and search capabilities
//   • Generate basic documentation for undocumented applications
//
// ARCHITECTURE:
//   - Core system service (NOT a user application)
//   - Loads early in system initialization before user apps
//   - Self-initializing service that listens for app registrations
//   - Provides window.Docs namespace for system-wide access
//   - No UI components - pure service layer
//
// INTEGRATION:
//   - Listens to EventBus 'app-registered' events
//   - Scans AppRegistry for existing applications
//   - Provides data to about.js and other documentation consumers
//   - Auto-generates docs for apps without explicit documentation
//
// LIFECYCLE:
//   1. Service loads with core system components
//   2. Auto-initializes when DOM ready or immediately if already loaded
//   3. Listens for new app registrations continuously
//   4. Provides documentation data to UI applications on request
//
// EXTENSION POINTS:
//   - Add documentation import/export functionality
//   - Support for external documentation sources (URLs, APIs)
//   - Documentation versioning and change tracking
//   - Integration with development tools for live documentation
//
// CUDOS:
//   edmundsparrow.netlify.app | whatsappme @ 09024054758 | 
//   webaplications5050@gmail.com
//
// NOTES:
//   - This is a SERVICE, not an application - no UI or app registration
//   - Must load before user applications to capture their documentation
//   - Provides the foundation for system-wide documentation access
//   - Self-documents for consistency with the documentation system
//
// ---------------------------------------------------------------------

// Core Documentation Service - System Service (Not an App)
window.Docs = {
    // Service state
    docRegistry: new Map(),
    isInitialized: false,
    
    // Configuration
    config: {
        autoGenerateDocs: true,
        collectOnRegistration: true,
        enableSearch: true,
        maxSearchResults: 50
    },

    /**
     * Initialize the documentation service
     * Called automatically on system startup
     */
    init() {
        if (this.isInitialized) {
            console.warn('Docs service already initialized');
            return;
        }
        
        console.log('Initializing Docs service...');
        
        // Listen for app registrations to collect their documentation
        if (window.EventBus && typeof window.EventBus.on === 'function') {
            window.EventBus.on('app-registered', (app) => {
                this.extractDocumentation(app.id, app);
            });
            console.log('Docs service listening for app registrations');
        } else {
            console.warn('EventBus not available - documentation collection may be incomplete');
        }
        
        // Scan existing registered apps for documentation
        this.scanExistingApps();
        
        // Register self-documentation
        this.registerSelfDocumentation();
        
        this.isInitialized = true;
        console.log('Docs service initialized successfully');
        
        // Emit initialization event for other services
        if (window.EventBus && typeof window.EventBus.emit === 'function') {
            window.EventBus.emit('docs-service-ready');
        }
    },

    /**
     * Scan existing apps in AppRegistry for documentation
     */
    scanExistingApps() {
        if (window.AppRegistry && window.AppRegistry.registeredApps) {
            let scannedCount = 0;
            window.AppRegistry.registeredApps.forEach((app, id) => {
                this.extractDocumentation(id, app);
                scannedCount++;
            });
            console.log(`Scanned ${scannedCount} existing apps for documentation`);
        }
    },

    /**
     * Extract documentation from app source or object
     * @param {string} appId - Application identifier
     * @param {Object} appObj - Application object from registry
     */
    extractDocumentation(appId, appObj) {
        if (!appId) {
            console.warn('Cannot extract documentation: missing app ID');
            return;
        }

        let doc = null;

        // Method 1: Check if app object has embedded documentation
        if (appObj && appObj.documentation) {
            doc = this.parseDocumentation(appObj.documentation, appId);
        }
        
        // Method 2: Check window namespace for documentation
        if (!doc && window[`${appId}App`] && window[`${appId}App`].documentation) {
            doc = this.parseDocumentation(window[`${appId}App`].documentation, appId);
        }
        
        // Method 3: Try to extract from source comments (development mode)
        if (!doc && this.config.autoGenerateDocs) {
            doc = this.tryExtractFromSource(appId);
        }
        
        // Method 4: Generate basic documentation from app registration
        if (!doc && this.config.autoGenerateDocs) {
            doc = this.generateBasicDoc(appId, appObj);
        }

        if (doc) {
            doc.id = appId;
            doc.lastUpdated = new Date().toISOString();
            doc.source = doc.auto_generated ? 'auto-generated' : 'manual';
            
            this.docRegistry.set(appId, doc);
            console.log(`Documentation registered for: ${appId} (${doc.source})`);
            
            // Emit documentation update event
            if (window.EventBus && typeof window.EventBus.emit === 'function') {
                window.EventBus.emit('documentation-updated', { appId, doc });
            }
        } else {
            console.warn(`Failed to extract documentation for: ${appId}`);
        }
    },

    /**
     * Parse documentation data from various formats
     * @param {string|Object} docData - Documentation data to parse
     * @param {string} appId - Application ID for error reporting
     * @returns {Object|null} Parsed documentation object
     */
    parseDocumentation(docData, appId) {
        try {
            if (typeof docData === 'string') {
                return JSON.parse(docData);
            } else if (typeof docData === 'object' && docData !== null) {
                return { ...docData };
            }
        } catch (e) {
            console.warn(`Failed to parse documentation for ${appId}:`, e);
        }
        return null;
    },

    /**
     * Attempt to extract documentation from source code comments
     * @param {string} appId - Application identifier
     * @returns {Object|null} Extracted documentation or null
     */
    tryExtractFromSource(appId) {
        // In development environment, this could parse JSDoc comments or similar
        // For production, this is a placeholder that returns null
        try {
            // Look for documentation patterns in loaded scripts
            const scripts = document.querySelectorAll('script[src]');
            for (let script of scripts) {
                if (script.src.includes(appId)) {
                    // In a real implementation, you'd fetch and parse the source
                    // For now, return null to fall back to basic doc generation
                    break;
                }
            }
        } catch (e) {
            console.debug(`Source extraction failed for ${appId}:`, e);
        }
        return null;
    },

    /**
     * Generate basic documentation for undocumented apps
     * @param {string} appId - Application identifier
     * @param {Object} appObj - Application registration object
     * @returns {Object} Basic documentation object
     */
    generateBasicDoc(appId, appObj) {
        return {
            name: (appObj && appObj.name) || this.formatAppName(appId),
            version: "1.0.0",
            description: `${(appObj && appObj.name) || this.formatAppName(appId)} application for webdesktop`,
            type: this.inferAppType(appId, appObj),
            features: ["Basic application functionality"],
            dependencies: ["WindowManager", "AppRegistry"],
            methods: [
                {
                    name: "open",
                    description: "Opens the application window"
                }
            ],
            notes: "Auto-generated documentation. Add proper documentation to the application source for detailed information.",
            auto_generated: true,
            generation_date: new Date().toISOString()
        };
    },

    /**
     * Format app ID into a readable name
     * @param {string} appId - Application identifier
     * @returns {string} Formatted application name
     */
    formatAppName(appId) {
        return appId
            .split('-')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    },

    /**
     * Infer application type from ID and registration
     * @param {string} appId - Application identifier
     * @param {Object} appObj - Application registration object
     * @returns {string} Inferred application type
     */
    inferAppType(appId, appObj) {
        // System apps and services
        const systemApps = ['startmenu', 'taskbar', 'desktop', 'settings', 'about'];
        const systemServices = ['docs', 'storage', 'eventbus', 'windowmanager'];
        
        if (systemApps.includes(appId) || (appObj && appObj.singleInstance)) {
            return "System App";
        }
        if (systemServices.includes(appId)) {
            return "System Service";
        }
        return "User App";
    },

    /**
     * Register documentation for the Docs service itself
     */
    registerSelfDocumentation() {
        const selfDoc = {
            name: "Documentation Service",
            version: "2.0.0",
            description: "Core system service that collects, manages, and provides access to application documentation across the webdesktop environment",
            type: "System Service",
            features: [
                "Automatic documentation collection from registered applications",
                "Multiple documentation source support (embedded, external, auto-generated)",
                "Real-time search and filtering capabilities with relevance scoring",
                "Documentation metadata management and versioning",
                "Auto-generation of basic documentation for undocumented applications",
                "Event-driven documentation updates and notifications"
            ],
            dependencies: ["EventBus (optional)", "AppRegistry (optional)"],
            methods: [
                { name: "init", description: "Initialize the documentation service and scan for existing apps" },
                { name: "getDocumentation", description: "Retrieve documentation for a specific application by ID" },
                { name: "getAllDocumentation", description: "Return array of all collected documentation objects" },
                { name: "searchDocumentation", description: "Search documentation with query string and relevance scoring" },
                { name: "registerDocumentation", description: "Manually register documentation for an application" },
                { name: "extractDocumentation", description: "Extract documentation from application objects and sources" }
            ],
            notes: "Core system service that must load before user applications to capture their documentation. Provides the foundation for system-wide documentation access through the about.js application and other documentation consumers.",
            cudos: "edmundsparrow.netlify.app | whatsappme @ 09024054758 | webaplications5050@gmail.com",
            auto_generated: false,
            id: 'docs',
            lastUpdated: new Date().toISOString(),
            source: 'manual'
        };
        
        this.docRegistry.set('docs', selfDoc);
    },

    // PUBLIC API METHODS

    /**
     * Get documentation for a specific application
     * @param {string} appId - Application identifier
     * @returns {Object|undefined} Documentation object or undefined if not found
     */
    getDocumentation(appId) {
        return this.docRegistry.get(appId);
    },

    /**
     * Get all collected documentation
     * @returns {Array} Array of all documentation objects
     */
    getAllDocumentation() {
        return Array.from(this.docRegistry.values());
    },

    /**
     * Search documentation with relevance scoring
     * @param {string} query - Search query string
     * @returns {Array} Array of matching documentation with relevance scores
     */
    searchDocumentation(query) {
        if (!query || !this.config.enableSearch) {
            return [];
        }

        const results = [];
        const searchTerm = query.toLowerCase().trim();
        
        this.docRegistry.forEach((doc, id) => {
            let relevance = 0;
            const searchableText = this.buildSearchableText(doc);

            if (searchableText.includes(searchTerm)) {
                // Calculate relevance score
                if (doc.name && doc.name.toLowerCase().includes(searchTerm)) {
                    relevance += 10;
                }
                if (doc.description && doc.description.toLowerCase().includes(searchTerm)) {
                    relevance += 5;
                }
                if (doc.features && doc.features.some(f => f.toLowerCase().includes(searchTerm))) {
                    relevance += 3;
                }
                if (searchableText.includes(searchTerm)) {
                    relevance += 1;
                }

                results.push({ ...doc, relevance, id });
            }
        });

        // Sort by relevance and limit results
        return results
            .sort((a, b) => b.relevance - a.relevance)
            .slice(0, this.config.maxSearchResults);
    },

    /**
     * Build searchable text from documentation object
     * @param {Object} doc - Documentation object
     * @returns {string} Searchable text string
     */
    buildSearchableText(doc) {
        const searchFields = [
            doc.name || '',
            doc.description || '',
            (doc.features || []).join(' '),
            doc.notes || '',
            (doc.methods || []).map(m => `${m.name} ${m.description || ''}`).join(' ')
        ];
        return searchFields.join(' ').toLowerCase();
    },

    /**
     * Manually register documentation for an application
     * @param {string} appId - Application identifier
     * @param {Object} docData - Documentation data object
     * @returns {boolean} True if registration successful
     */
    registerDocumentation(appId, docData) {
        if (!appId || !docData) {
            console.warn('Cannot register documentation: missing appId or docData');
            return false;
        }

        const doc = this.parseDocumentation(docData, appId);
        if (doc) {
            doc.id = appId;
            doc.lastUpdated = new Date().toISOString();
            doc.source = 'manual';
            doc.auto_generated = false;
            
            this.docRegistry.set(appId, doc);
            console.log(`Manual documentation registered for: ${appId}`);
            
            // Emit update event
            if (window.EventBus && typeof window.EventBus.emit === 'function') {
                window.EventBus.emit('documentation-updated', { appId, doc });
            }
            
            return true;
        }
        return false;
    },

    // UTILITY METHODS

    /**
     * Get system applications documentation
     * @returns {Array} Array of system app documentation
     */
    getSystemApps() {
        return this.getAllDocumentation().filter(doc => 
            doc.type === "System App" || doc.type === "System Service"
        );
    },

    /**
     * Get user applications documentation
     * @returns {Array} Array of user app documentation
     */
    getUserApps() {
        return this.getAllDocumentation().filter(doc => doc.type === "User App");
    },

    /**
     * Get apps by category
     * @param {string} category - Category to filter by
     * @returns {Array} Array of documentation for apps in category
     */
    getAppsByCategory(category) {
        return this.getAllDocumentation().filter(doc => doc.category === category);
    },

    /**
     * Get documentation statistics
     * @returns {Object} Statistics about documentation collection
     */
    getStatistics() {
        const allDocs = this.getAllDocumentation();
        const autoGenerated = allDocs.filter(doc => doc.auto_generated);
        const systemDocs = this.getSystemApps();
        const userDocs = this.getUserApps();

        return {
            total: allDocs.length,
            system: systemDocs.length,
            user: userDocs.length,
            auto_generated: autoGenerated.length,
            manual: allDocs.length - autoGenerated.length,
            last_update: Math.max(...allDocs.map(doc => 
                new Date(doc.lastUpdated || doc.generation_date || 0).getTime()
            ))
        };
    },

    /**
     * Export all documentation as JSON
     * @returns {string} JSON string of all documentation
     */
    exportDocumentation() {
        const exportData = {
            exported: new Date().toISOString(),
            version: "2.0.0",
            service_info: {
                total_apps: this.docRegistry.size,
                statistics: this.getStatistics()
            },
            documentation: Object.fromEntries(this.docRegistry)
        };
        return JSON.stringify(exportData, null, 2);
    },

    /**
     * Check if service is ready
     * @returns {boolean} True if service is initialized and ready
     */
    isReady() {
        return this.isInitialized;
    },

    /**
     * Get service configuration
     * @returns {Object} Current service configuration
     */
    getConfig() {
        return { ...this.config };
    }
};

// Auto-initialize the documentation service
// This runs when the script loads, ensuring the service is ready before user apps
(function initializeDocsService() {
    const initService = () => {
        if (!window.Docs.isInitialized) {
            try {
                window.Docs.init();
            } catch (error) {
                console.error('Failed to initialize Docs service:', error);
            }
        }
    };

    // Initialize immediately if DOM is ready, otherwise wait for it
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initService);
    } else {
        // DOM already loaded, initialize with a small delay to ensure other core services are loaded
        setTimeout(initService, 50);
    }

    // Also initialize when the window loads as a fallback
    window.addEventListener('load', () => {
        if (!window.Docs.isInitialized) {
            initService();
        }
    });
})();

// Export for module environments (if needed)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = window.Docs;
}
